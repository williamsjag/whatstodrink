# What's to drink?

### Video Demo: [<What's to Drink?>](https://youtu.be/QQenGLLopX4)

#### Description:

**What's to drink** is a webapp that keeps track of cocktail recipes and the inventory of ingredients necessary to make them. Its most important feature is that it will show you every cocktail in your recipe collection that you can make with the ingredients you have on hand.

The experience starts on the **Login** page, where the user will be prompted to log in and presented wtih a link to the registration page if they do not already have an account. When a form is submitted to **Register**, the form will be submitted via POST to Flask, which will verify that the passwords match and make sure that there isn't already a user with that name. It will then save the new user's username and a hash of their password to the users table of cocktails.db before redirecting them to the login page.

Back at **Login**, once the user enters their new username and password, the /login route in Flask will check to make sure the login form was filled in properly and that the password is correct, and then assign a session id to that user. Login will then check the database table of common_ingredients to see if the user already has their user id associated with values of all of the pre-existing ingredients. If not, it will assign them a default value (0) for each ingredient they are not already associated with. This is especially important for new accounts, enabling the database to update their stock of the common ingredients. The other benefit of this action is that it permits the user to have access to common ingredients that may be created after they created their account. Once logged in, the user is redirected to the index page.

On the **Index** page is a brief welcome message as well as a tour of what each page linked from the menu bar is for. I decided not to include this page on the menu bar as it doesn't really function like a typical homepage and is more intended as a very brief introduction to the site. There also isn't any information here that is not better explained elsewhere.

Before moving on to the other pages in the site it will be  important to understand the database structure behind it. It consists of 9 (8 currently used) tables which serve to keep user data separate from the common cocktails that every user is able to access. Every user can see the common information, but user writes are only made to tables that store only user data.

### The Tables

   1. **users**: This table stores the user id, username, and password hash of every registered user.
   2. **common_cocktails**: This table stores the id, name, and associated metadata for each of the cocktails that are available to every user.
   3. **common_ingredients**: This stores the id, name, and type of all of the commonly available ingredients.
   4. **common_amounts**: This is a linking table that associates cocktail_id to the id of the cocktails table, and ingredient_id to the id of the common ingredients table, as well as an amount. This enables recipes to be created. Each entry holds the amount of one ingredient that goes in one cocktail.
   5. **common_stock**: The last of the 'common' tables. This stores ingredient ids (linking to ingredients), user ids (linking to users), and a checkmark value called stock. This allows the site to associate a stock value for each user for each ingredient, therefore keeping user data away from the common data.
   6. **cocktails**: The user version of common cocktails. This holds one extra field, user_id, which serves to identify which user added the cocktail.
   7. **amounts**: The user version of common amounts. This stores one extra field, ingredient_source, which is filled in by Flask when the user adds a cocktail. This permits a user to use a mixture of user added ingredients and common ingredients in creating their cocktails.
   8. **ingredients**: The last functional table. The user version of common ingredients. There are two extra fields here: user_id, which tracks the user who added this ingredient, and stock, which serves the same function as it does in the common stock table, but here since the user_id is recorded with the ingredient, there is no need for a separate table.
   (9.) **ratings**: This is currently under development for a future ratings feature. 

The **Manage Ingredients** page serves a series of tables presented in a number of columns according to screen size. This data is pulled from the cocktails database when a GET request is received for the /manageingredients route. The Flask backend is then doing a query of both the common ingredients table as well as ingredients to find every common ingredient plus every user ingredient associated with the current user's id. It also saves every ingredient type in that dataset as a variable and passes it to the frontend, which loops through those type variables to create a table of ingredients which match each type. It then presents those ingredients along with a checkbox which reflects the current user's stock of that ingredient, whether it was added by them or is a common one. It also saves each ingredient's id and source values as hidden items in the table so it can communicate them back to Flask when they are needed.

The user can then update their stock of each ingredient by checking or unchecking the checkboxes. When the user clicks the Update button, it POSTS all of this back to Flask, which updates the stock in the database by first setting all stock associated with the user to '0', then looping through each item in the form, checking the source and ingredient id to find where to go, and then setting stock to 'on' if the box for that ingredient was checked. It then redirects the user back to manageingredients.

**Add Ingredient** via GET is a fairly simple form, with brief instructions prompting the user to fill it out. Once a name and type is submitted, Flask checks to make sure the form is filled out, then searches both ingredients and common ingredients to see if an ingredient by that name already exists. If not, it will add it to the ingredients table and redirect back to Add Ingredient.

**Add Cocktail** is the most involved page in terms of user experience as well as Flask backend. On arrival via GET, the user is presented with a form for adding the necessary information as well as instructions on how to use the page and some information about cocktail families for those who may be unfamiliar. The ingredient select field here is populated from a database query from Flask when the user loads the page. Then a Jinja loop sets options for each type in both common and user ingredients, then values of each ingredient that matches those type. This approach seemed like a great solution when there were few ingredients in the database because they were easy to find separated by type like this. Now however, I realize that it is very unweildy to hunt through a list of 150+ options to find what you are looking for. I plan to change this to an auto-completing text field in the future for both ease and speed of input.

If the user selects the option --Create New Ingredient--, it will open a modal window through a JavaScript function which watches the select field for changes and opens it if a field with a link in its value is selected. The user can then add a new ingredient without having to leave the page to go to Add Ingredient. The list will then refresh itself with the new option in place and ready to use.

Once an ingredient is added (or before if the user prefers), the 'More Ingredients' button when clicked will dynamically create a new ingredient select menu via a JavaScript function that finds the id of the select menu and copies its innerHTML into a new list element in the ingredient list and appends it to the div of the list. It then adds a new onchange listener for the new select menu which watches for --Create New Ingredient-- there.

Once the user is satisfied with the information input to the form and clicks the Add Cocktail button, it submits this form via POST and Flask searches both common cocktails and cocktails to verify that this user doesn't already have a cocktail by that name, and if not adds the cocktail with its metadata to the cocktails table of the database. It also queries the database for the just-assigned cocktail id using its name and the user id, which it passes to the Amounts page.

**Amounts** is only accessible via POST from Add Cocktail is is responsible for associating amounts between the selected ingredients and the new cocktail. It presents the user with a table consisting of the ingredients they added in the Add Cocktail form with a text field for inputting the amount of each. When submitted, Flask takes the values from the form and for each ingredient, searches both the common ingredients and ingredients tables for the ingredient to assign it a source value via a UNION query. Then it writes an entry to the amounts table including both the source value and the user's id. If completed successfully, the user is presented with a success message and a link to add another cocktail.

**What's to drink** is the heart of the app. This page only takes GET requests, and is what all the other pages are building toward. When the page is requested, the Flask backend performs a query which touches every table of the database in order to find which cocktails are able to be made. It does this by joining all of the common tables together and performing a SELECT query for cocktails (filtering out ingredients not in stock) where the count of ingredients remaining (in stock) is equal to the total count of ingredients for that cocktail. This is one half of a UNION query that also performs a version of the top half on the user tables, filtering for only data associated with that user id. The resulting list of cocktails ready to be made is then passed to the frontend along with lists generated from other queries of ingredients, amounts, and families concerned.

The HTML code for this page is a web of Jinja loops which starts on the farthest out layer cycling through the list of families passed from Flask to group the results. Then in each family, for each cocktail which belongs to it, it creates a Bootstrap accordion with the cocktail name in the button. Then for each ingredient, it starts a loop through amounts. For each amount, if it contains the cocktail id of the current cocktail and the ingredient id of the current ingredient, it is added to a list of ingredients for this cocktail. Once all the loops within the current cocktail are completed, it adds the complete list of ingredients for the cocktail to the right side of the button, so that both the name of the cocktail and its ingredients can be seen at a glance, even with the accordion closed.

Once the button is finished, it populates the body, setting the tags for the div containing it to reference the loop index so there are no conflicting id tags. It populates the body by looping through the amounts received from Flask, and if the cocktail id matches the current cocktail it displays the amount and then cycles through the set of ingredients in the cocktail to find the one that matches its ingredient id to present the pair like you would read in a recipe book: "1 ounce Lime juice." There is then a line break and the process repeats for the rest of the ingredients.

The rest of the accordion body consists of labels on the left indicating what field is being presented and the related cocktail metadata from this point in the loop.

What is shown when the loops are all finished is a complete list of closed accordions showing every cocktail, including common access and user submissions, the user can make with what they have on hand and their ingredients. When opened, the accordions show the complete recipe assembled from fields in the various amounts, cocktails, and ingredients tables presented in a human readable format.

## The Future

* As mentioned above, the ingredient selection mechanism for Add Cocktail needs to be changed. In doing this, I will also need to change the outside-in naming convention for ingredients sharing a category (e.g. "Whisky - Scotch - Blended") as that decision was made for ease of finding the ingredient in the select menu, but in practice clutters up the buttons on the accordions and makes them difficult to read at a glance.
* I also plan to make a page that will show the cocktails that can *almost* be made, missing one ingredient. I also want to show a count of the number of cocktails that will be enabled by adding an ingredient, perhaps on that page, showing the top 5 ingredients that will add the highest number of possibilities.
* I want to implement a way to view all cocktails the user has access to in the database, as well as ways to modify already created cocktails and ingredients.
* I want to add a tags system, so that user can customize filterable options aside from the predetermined cocktail families.
* I want to add a rating system so a user can note their thoughts on each creation (table 9)

With that, this has been "What's to Drink?"
